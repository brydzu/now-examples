diff --git a/node_modules/@grafoo/core/.DS_Store b/node_modules/@grafoo/core/.DS_Store
new file mode 100644
index 0000000..2895c21
Binary files /dev/null and b/node_modules/@grafoo/core/.DS_Store differ
diff --git a/node_modules/@grafoo/core/dist/index.js b/node_modules/@grafoo/core/dist/index.js
index 0c6417a..7c60294 100644
--- a/node_modules/@grafoo/core/dist/index.js
+++ b/node_modules/@grafoo/core/dist/index.js
@@ -1,2 +1,2 @@
-var r=function(r,a){r=r||{};for(var t="",n=0;n<a.length;n++)r[a[n]]&&(t+=r[a[n]]);return t},a=function(r){return r&&"object"==typeof r},t=function(r,a,t){t=t||{};for(var n=r,e=a.length;e--;)n+=":"+t[a[e]];return n};function n(t,n,e){var o=t,i=[];for(var s in o)i.push([s,o]);for(;i.length;){var f=i.pop(),v=f[1][f[0]],u=r(v,e),c=n[u];for(var p in Object.assign({},v,c))u&&c&&(v[p]=c[p]||v[p]),a(v[p])&&i.push([p,v])}return o}function e(t,n){var e={},o=[];for(var i in t)o.push(t[i]);for(;o.length;){var s=o.pop(),f={};for(var v in s){var u=s[v];a(u)&&o.push(u)||(f[v]=u)}var c=r(s,n);c&&(e[c]=Object.assign({},e[c],f))}return e}export default function(r,a){var o=a.idFields,i=a.initialState||{pathsMap:{},objectsMap:{}},s=i.pathsMap,f=i.objectsMap,v=[];return{execute:function(a,t){var n=a.query,e=a.frags,o=a.id;if(e)for(var i in e)n+=e[i];return r(n,t,o)},listen:function(r){return v.push(r),function(){var a=v.indexOf(r);a<0||v.splice(a,1)}},write:function(r,a,n){var i=r.paths;n||(n=a,a=void 0);var u={};for(var c in i){var p=i[c],h=p.name,l=p.args,b={};b[h]=n.data?n.data[h]:n[h];var j=e(b,o);Object.assign(u,j),s[t(c,l,a)]={data:b,objects:Object.keys(j)}}for(var d in u)f[d]=u[d]=Object.assign({},f[d],u[d]);var g=[];for(var O in s)g=g.concat(s[O].objects);var M=new Set(g);for(var y in f)M.has(y)||delete f[y];for(var x in v)v[x](u)},read:function(r,a){var e=r.paths,i={},v={},u=!1;for(var c in e){var p=e[c],h=p.name,l=s[t(c,p.args,a)];if(l){i[h]=l.data[h];for(var b=0,j=l.objects;b<j.length;b+=1){var d=j[b];v[d]=f[d]}}else u=!0}return Object.keys(i).length?{data:n(i,f,o),objects:v,partial:u}:{}},flush:function(){return{objectsMap:f,pathsMap:s}},reset:function(){s={},f={}}}}
+var r=function(r,a){r=r||{};for(var t="",n=0;n<a.length;n++)r[a[n]]&&(t+=r[a[n]]);return t},a=function(r){return r&&"object"==typeof r},t=function(r,a,t){t=t||{};for(var n=r,e=a.length;e--;)n+=":"+t[a[e]];return n};function n(t,n,e){var o=t,i=[];for(var s in o)i.push([s,o]);for(;i.length;){var f=i.pop(),v=f[1][f[0]],u=r(v,e),c=n[u];for(var p in Object.assign({},v,c))u&&c&&(v[p]=c[p]||v[p]),a(v[p])&&i.push([p,v])}return o}function e(t,n){var e={},o=[];for(var i in t)o.push(t[i]);for(;o.length;){var s=o.pop(),f={};for(var v in s){var u=s[v];a(u)&&o.push(u)||(f[v]=u)}var c=r(s,n);c&&(e[c]=Object.assign({},e[c],f))}return e}module.exports=function(r,a){var o=a.idFields,i=a.initialState||{pathsMap:{},objectsMap:{}},s=i.pathsMap,f=i.objectsMap,v=[];return{execute:function(a,t){var n=a.query,e=a.frags,o=a.id;if(e)for(var i in e)n+=e[i];return r(n,t,o)},listen:function(r){return v.push(r),function(){var a=v.indexOf(r);a<0||v.splice(a,1)}},write:function(r,a,n){var i=r.paths;n||(n=a,a=void 0);var u={};for(var c in i){var p=i[c],h=p.name,l=p.args,b={};b[h]=n.data?n.data[h]:n[h];var j=e(b,o);Object.assign(u,j),s[t(c,l,a)]={data:b,objects:Object.keys(j)}}for(var d in u)f[d]=u[d]=Object.assign({},f[d],u[d]);var g=[];for(var O in s)g=g.concat(s[O].objects);var M=new Set(g);for(var y in f)M.has(y)||delete f[y];for(var m in v)v[m](u)},read:function(r,a){var e=r.paths,i={},v={},u=!1;for(var c in e){var p=e[c],h=p.name,l=s[t(c,p.args,a)];if(l){i[h]=l.data[h];for(var b=0,j=l.objects;b<j.length;b+=1){var d=j[b];v[d]=f[d]}}else u=!0}return Object.keys(i).length?{data:n(i,f,o),objects:v,partial:u}:{}},flush:function(){return{objectsMap:f,pathsMap:s}},reset:function(){s={},f={}}}};
 //# sourceMappingURL=index.js.map
diff --git a/node_modules/@grafoo/core/dist/index.js.map b/node_modules/@grafoo/core/dist/index.js.map
index c8e9b4f..c8e1d61 100644
--- a/node_modules/@grafoo/core/dist/index.js.map
+++ b/node_modules/@grafoo/core/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":[],"sourcesContent":[],"names":[],"mappings":""}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":["../src/util.ts","../src/build-query-tree.ts","../src/map-objects.ts","../src/index.ts"],"sourcesContent":["import { Variables } from \"@grafoo/types\";\n\nexport let idFromProps = (branch, idFields) => {\n  branch = branch || {};\n  let identifier = \"\";\n\n  for (let i = 0; i < idFields.length; i++) {\n    branch[idFields[i]] && (identifier += branch[idFields[i]]);\n  }\n\n  return identifier;\n};\n\nexport let isNotNullObject = obj => obj && typeof obj == \"object\";\n\nexport let getPathId = (path: string, args: string[], variables?: Variables) => {\n  variables = variables || {};\n  let finalPath = path;\n  let i = args.length;\n\n  while (i--) finalPath += \":\" + variables[args[i]];\n\n  return finalPath;\n};\n","import { idFromProps, isNotNullObject } from \"./util\";\n\nexport default function buildQueryTree(tree, objects, idFields) {\n  // clone resulting query tree\n  let queryTree = tree;\n  let stack = [];\n\n  // populates stack with the properties of the query tree and the query tree it self\n  for (let i in queryTree) stack.push([i, queryTree]);\n\n  // will loop until the stack is empty\n  while (stack.length) {\n    // pops a stack entry extracting the current key of the tree's branch\n    // (eg: a node or an edge) and the branch it self\n    let [key, currentTree] = stack.pop();\n    // assigns nested branch\n    let branch = currentTree[key];\n    // get node identifier\n    let identifier = idFromProps(branch, idFields);\n    // possible node matching object\n    let branchObject = objects[identifier];\n\n    // iterates over the child branch properties\n    for (let i in Object.assign({}, branch, branchObject)) {\n      // assigns to the child branch all properties retrieved\n      // from the corresponding object retrieved from the objects cache\n      if (identifier && branchObject) branch[i] = branchObject[i] || branch[i];\n\n      // pushes properties of the child branch and the branch it self to the stack\n      if (isNotNullObject(branch[i])) stack.push([i, branch]);\n    }\n  }\n\n  return queryTree;\n}\n","import { isNotNullObject, idFromProps } from \"./util\";\n\nexport default function mapObjects(tree, idFields) {\n  // map in which objects will be stored\n  // having their extracted ids from props as key\n  let map = {};\n  let stack = [];\n\n  // populates the stack with the tree branches\n  for (let i in tree) stack.push(tree[i]);\n\n  // will run until the stack is empty\n  while (stack.length) {\n    // pops the current branch from the stack\n    let branch = stack.pop();\n    // next node to be traversed. nested branches will be removed\n    let filteredBranch = {};\n\n    // iterate over branch properties\n    // if the property is a branch it will be added to the stack\n    // else if it is not a branch it will be added to filtered branch\n    for (let i in branch) {\n      let branchVal = branch[i];\n      (isNotNullObject(branchVal) && stack.push(branchVal)) || (filteredBranch[i] = branchVal);\n    }\n\n    // node identifier\n    let identifier = idFromProps(branch, idFields);\n\n    // if branch is a node, assign the value of filtered branch to it\n    if (identifier) map[identifier] = Object.assign({}, map[identifier], filteredBranch);\n  }\n\n  return map;\n}\n","import {\n  GrafooClient,\n  GrafooClientOptions,\n  GrafooObject,\n  Listener,\n  ObjectsMap,\n  Variables,\n  GrafooTransport\n} from \"@grafoo/types\";\nimport buildQueryTree from \"./build-query-tree\";\nimport mapObjects from \"./map-objects\";\nimport { getPathId } from \"./util\";\n\nexport default function createClient(\n  transport: GrafooTransport,\n  options?: GrafooClientOptions\n): GrafooClient {\n  let { initialState, idFields } = options;\n  let { pathsMap, objectsMap } = initialState || { pathsMap: {}, objectsMap: {} };\n  let listeners: Listener[] = [];\n\n  function execute<T>({ query, frags, id }: GrafooObject, variables?: Variables) {\n    if (frags) for (let frag in frags) query += frags[frag];\n\n    return transport<T>(query, variables, id);\n  }\n\n  function listen(listener: Listener) {\n    listeners.push(listener);\n\n    return () => {\n      let index = listeners.indexOf(listener);\n\n      if (index < 0) return;\n\n      listeners.splice(index, 1);\n    };\n  }\n\n  function write<T>({ paths }: GrafooObject, variables: Variables, data?: T | { data: T }) {\n    if (!data) {\n      data = variables as typeof data;\n      variables = undefined;\n    }\n\n    let objects: ObjectsMap = {};\n\n    for (let i in paths) {\n      let { name, args } = paths[i];\n      let pathData = {\n        [name]: (data as { data: T }).data ? (data as { data: T }).data[name] : data[name]\n      };\n      let pathObjects = mapObjects(pathData, idFields);\n\n      Object.assign(objects, pathObjects);\n\n      pathsMap[getPathId(i, args, variables)] = {\n        data: pathData,\n        objects: Object.keys(pathObjects)\n      };\n    }\n\n    // assign new values to objects in objectsMap\n    for (let i in objects) {\n      objectsMap[i] = objects[i] = Object.assign({}, objectsMap[i], objects[i]);\n    }\n\n    // clean cache\n    let pathsObjects = [];\n    for (let i in pathsMap) pathsObjects = pathsObjects.concat(pathsMap[i].objects);\n    let allObjects = new Set(pathsObjects);\n    for (let i in objectsMap) if (!allObjects.has(i)) delete objectsMap[i];\n\n    // run listeners\n    for (let i in listeners) listeners[i](objects);\n  }\n\n  function read({ paths }: GrafooObject, variables?: Variables) {\n    let data = {};\n    let objects: ObjectsMap = {};\n    let partial = false;\n\n    for (let i in paths) {\n      let { name, args } = paths[i];\n      let currentPath = pathsMap[getPathId(i, args, variables)];\n\n      if (currentPath) {\n        data[name] = currentPath.data[name];\n\n        for (let i of currentPath.objects) objects[i] = objectsMap[i];\n      } else {\n        partial = true;\n      }\n    }\n\n    return Object.keys(data).length\n      ? { data: buildQueryTree(data, objectsMap, idFields), objects, partial }\n      : {};\n  }\n\n  function flush() {\n    return { objectsMap, pathsMap };\n  }\n\n  function reset() {\n    pathsMap = {};\n    objectsMap = {};\n  }\n\n  return { execute, listen, write, read, flush, reset };\n}\n"],"names":["let","idFromProps","branch","idFields","identifier","i","length","isNotNullObject","obj","getPathId","path","args","variables","finalPath","buildQueryTree","tree","objects","queryTree","stack","push","pop","branchObject","Object","assign","mapObjects","map","filteredBranch","branchVal","transport","options","pathsMap","objectsMap","listeners","ref","frags","frag","query","id","listener","index","indexOf","splice","data","undefined","paths","pathData","name","pathObjects","keys","pathsObjects","concat","allObjects","Set","has","partial","currentPath"],"mappings":"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"}
\ No newline at end of file
